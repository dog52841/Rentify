-- Rentify Final Schema Setup
-- Version 5
-- This is the single, definitive script to set up your database schema correctly.
-- It is idempotent and can be run multiple times safely.

-- Enable PostGIS extension for geometry support
-- This is necessary for location-based features.
-- If you get a permission error on this line, you may need to enable it via the Supabase Dashboard under Database > Extensions.
CREATE EXTENSION IF NOT EXISTS postgis;

-- Enable UUID generation
-- Required for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 1. Drop existing tables in reverse order of dependency to avoid errors.
-- This ensures a clean slate and resolves any lingering schema inconsistencies.
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.user_reviews CASCADE;
DROP TABLE IF EXISTS public.favorites CASCADE;
DROP TABLE IF EXISTS public.bookings CASCADE;
DROP TABLE IF EXISTS public.conversations CASCADE;
DROP TABLE IF EXISTS public.listings CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 2. Create tables

-- Profiles table to store user information, linked to Supabase Auth.
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY,
    updated_at timestamp with time zone,
    full_name text,
    avatar_url text,
    stripe_connect_id text,
    stripe_customer_id text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    role text NOT NULL DEFAULT 'user', -- 'user' or 'admin'
    is_banned boolean NOT NULL DEFAULT false,
    ban_reason text,
    ban_expires_at timestamptz
);

-- Listings table for all rental items
CREATE TABLE IF NOT EXISTS public.listings (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    title text,
    description text,
    price_per_day numeric,
    location text,
    location_lat numeric,
    location_lng numeric,
    location_geom geometry(point, 4326),
    location_text text,
    owner_id uuid REFERENCES public.profiles(id),
    images_urls text[],
    image_360_url text,
    category text,
    view_count integer DEFAULT 0,
    status text NOT NULL DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    is_verified boolean NOT NULL DEFAULT false,
    rejection_reason text
);

-- Bookings table to manage rentals
CREATE TABLE IF NOT EXISTS public.bookings (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    listing_id uuid REFERENCES public.listings(id),
    renter_id uuid REFERENCES public.profiles(id),
    start_date date,
    end_date date,
    total_price numeric,
    status text,
    view_count integer,
    average_rating numeric,
    review_count bigint,
    is_verified boolean
);

-- User reviews table
CREATE TABLE IF NOT EXISTS public.user_reviews (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    booking_id bigint REFERENCES public.bookings(id) ON DELETE CASCADE,
    reviewer_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    reviewee_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    rating integer NOT NULL,
    review_text text,
    listing_id uuid REFERENCES public.listings(id) ON DELETE CASCADE
);

-- Favorites table
CREATE TABLE IF NOT EXISTS public.favorites (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    listing_id uuid NOT NULL REFERENCES public.listings(id) ON DELETE CASCADE,
    UNIQUE(user_id, listing_id)
);

-- Conversations table for messaging
CREATE TABLE IF NOT EXISTS public.conversations (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    listing_id uuid REFERENCES public.listings(id),
    owner_id uuid REFERENCES public.profiles(id),
    renter_id uuid REFERENCES public.profiles(id)
);

-- Messages table
CREATE TABLE IF NOT EXISTS public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now(),
    conversation_id uuid REFERENCES public.conversations(id) ON DELETE CASCADE,
    sender_id uuid REFERENCES public.profiles(id),
    content text
);

-- 2. Add PostGIS column and update geometry if possible
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'postgis'
    ) THEN
        -- Add PostGIS column if it doesn't exist
        IF NOT EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name = 'listings' AND column_name = 'location_geom'
        ) THEN
            EXECUTE 'ALTER TABLE public.listings ADD COLUMN location_geom geometry(point, 4326);';
        END IF;

        -- Only update if lat/lng columns exist
        IF EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name = 'listings' AND column_name = 'location_lat'
        ) AND EXISTS (
            SELECT 1 FROM information_schema.columns
            WHERE table_name = 'listings' AND column_name = 'location_lng'
        ) THEN
            UPDATE public.listings
            SET location_geom = ST_SetSRID(ST_MakePoint(location_lng, location_lat), 4326)
            WHERE location_geom IS NULL AND location_lat IS NOT NULL AND location_lng IS NOT NULL;
        END IF;
    END IF;
END
$$;

-- 2. Set up Row Level Security (RLS) policies

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

ALTER TABLE public.listings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Listings are viewable by everyone." ON public.listings;
CREATE POLICY "Listings are viewable by everyone." ON public.listings FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can insert their own listings." ON public.listings;
CREATE POLICY "Users can insert their own listings." ON public.listings FOR INSERT WITH CHECK (auth.uid() = owner_id);
DROP POLICY IF EXISTS "Users can update their own listings." ON public.listings;
CREATE POLICY "Users can update their own listings." ON public.listings FOR UPDATE USING (auth.uid() = owner_id);
DROP POLICY IF EXISTS "Users can delete their own listings." ON public.listings;
CREATE POLICY "Users can delete their own listings." ON public.listings FOR DELETE USING (auth.uid() = owner_id);

ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own bookings." ON public.bookings;
CREATE POLICY "Users can view their own bookings." ON public.bookings FOR SELECT USING (auth.uid() = renter_id OR auth.uid() = (SELECT owner_id FROM listings WHERE id = listing_id));
DROP POLICY IF EXISTS "Users can create bookings." ON public.bookings;
CREATE POLICY "Users can create bookings." ON public.bookings FOR INSERT WITH CHECK (auth.uid() = renter_id);
DROP POLICY IF EXISTS "Owners can update booking status." ON public.bookings;
CREATE POLICY "Owners can update booking status." ON public.bookings FOR UPDATE USING (auth.uid() = (SELECT owner_id FROM listings WHERE id = listing_id));

ALTER TABLE public.user_reviews ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Reviews are viewable by everyone." ON public.user_reviews;
CREATE POLICY "Reviews are viewable by everyone." ON public.user_reviews FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can insert their own reviews." ON public.user_reviews;
CREATE POLICY "Users can insert their own reviews." ON public.user_reviews FOR INSERT WITH CHECK (auth.uid() = reviewer_id);

ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own favorites." ON public.favorites;
CREATE POLICY "Users can view their own favorites." ON public.favorites FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can manage their own favorites." ON public.favorites;
CREATE POLICY "Users can manage their own favorites." ON public.favorites FOR ALL USING (auth.uid() = user_id);

ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own conversations." ON public.conversations;
CREATE POLICY "Users can view their own conversations." ON public.conversations FOR SELECT USING (auth.uid() = owner_id OR auth.uid() = renter_id);
DROP POLICY IF EXISTS "Users can start conversations." ON public.conversations;
CREATE POLICY "Users can start conversations." ON public.conversations FOR INSERT WITH CHECK (auth.uid() = renter_id);

ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own messages" ON public.messages;
CREATE POLICY "Users can view their own messages" ON public.messages FOR SELECT
USING (
  id IN (
    SELECT msg.id FROM public.messages msg
    JOIN public.conversations convo ON msg.conversation_id = convo.id
    WHERE convo.renter_id = auth.uid() OR convo.owner_id = auth.uid()
  )
);
DROP POLICY IF EXISTS "Users can send messages in their own conversations" ON public.messages;
CREATE POLICY "Users can send messages in their own conversations" ON public.messages FOR INSERT
WITH CHECK (
  sender_id = auth.uid() AND
  conversation_id IN (
    SELECT id FROM public.conversations WHERE renter_id = auth.uid() OR owner_id = auth.uid()
  )
);


-- 3. Create database functions

-- Function to increment listing view count
DROP FUNCTION IF EXISTS public.increment_listing_count(p_listing_id uuid);
DROP FUNCTION IF EXISTS public.increment_listing_view_count(p_listing_id uuid);
CREATE OR REPLACE FUNCTION public.increment_listing_view_count(p_listing_id uuid)
RETURNS void
LANGUAGE sql
AS $$
  UPDATE public.listings
  SET view_count = view_count + 1
  WHERE id = p_listing_id;
$$;
GRANT EXECUTE ON FUNCTION public.increment_listing_view_count(p_listing_id uuid) TO authenticated, service_role;

-- Drop both potential old function signatures to resolve ambiguity
DROP FUNCTION IF EXISTS public.get_listings_with_ratings(text, text, numeric, numeric, numeric, double precision, double precision, integer, integer, integer, text, text, uuid, uuid);
DROP FUNCTION IF EXISTS public.get_listings_with_ratings(text, text, numeric, numeric, numeric, numeric, numeric, numeric, integer, integer, text, text, uuid, uuid);

-- Function to get listings with filters, sorting, and ratings
CREATE OR REPLACE FUNCTION public.get_listings_with_ratings(
    p_search_term TEXT DEFAULT NULL,
    p_category TEXT DEFAULT NULL,
    p_min_price NUMERIC DEFAULT NULL,
    p_max_price NUMERIC DEFAULT NULL,
    p_min_rating NUMERIC DEFAULT NULL,
    p_user_lon FLOAT DEFAULT NULL,
    p_user_lat FLOAT DEFAULT NULL,
    p_nearby_radius INT DEFAULT NULL, -- in meters
    p_limit INT DEFAULT 20,
    p_offset INT DEFAULT 0,
    p_sort_column TEXT DEFAULT 'created_at',
    p_sort_direction TEXT DEFAULT 'desc',
    p_owner_id UUID DEFAULT NULL,
    p_exclude_owner_id UUID DEFAULT NULL
)
RETURNS TABLE(
    id uuid,
    created_at timestamptz,
    title text,
    description text,
    price_per_day numeric,
    location_lat numeric,
    location_lng numeric,
    location_geom geometry,
    location_text text,
    owner_id uuid,
    images_urls text[],
    image_360_url text,
    category text,
    view_count integer,
    average_rating numeric,
    review_count bigint,
    is_verified boolean
)
AS $$
BEGIN
RETURN QUERY
SELECT
    l.id,
    l.created_at,
    l.title,
    l.description,
    l.price_per_day,
    l.location_lat,
    l.location_lng,
    l.location_geom,
    l.location_text,
    l.owner_id,
    l.images_urls,
    l.image_360_url,
    l.category,
    l.view_count,
    COALESCE(rev.average_rating, 0) as average_rating,
    COALESCE(rev.review_count, 0) as review_count,
    l.is_verified
FROM
    public.listings l
LEFT JOIN
    (
        SELECT
            ur.listing_id,
            AVG(ur.rating)::numeric(2,1) as average_rating,
            COUNT(ur.id) as review_count
        FROM
            public.user_reviews ur
        GROUP BY
            ur.listing_id
    ) rev ON l.id = rev.listing_id
WHERE
    (p_search_term IS NULL OR l.title ILIKE '%' || p_search_term || '%' OR l.description ILIKE '%' || p_search_term || '%')
AND
    (p_category IS NULL OR l.category = p_category)
AND
    (p_min_price IS NULL OR l.price_per_day >= p_min_price)
AND
    (p_max_price IS NULL OR l.price_per_day <= p_max_price)
AND
    (p_min_rating IS NULL OR COALESCE(rev.average_rating, 0) >= p_min_rating)
AND
    (p_owner_id IS NULL OR l.owner_id = p_owner_id)
AND
    (p_exclude_owner_id IS NULL OR l.owner_id != p_exclude_owner_id)
AND
    l.status = 'approved' -- Only show approved listings publicly
AND
    (
        -- Geospatial query, only if all location params are provided
        p_user_lon IS NULL OR p_user_lat IS NULL OR p_nearby_radius IS NULL OR
        ST_DWithin(
            l.location_geom,
            ST_SetSRID(ST_MakePoint(p_user_lon, p_user_lat), 4326),
            p_nearby_radius
        )
    )
ORDER BY
    CASE WHEN p_sort_column = 'created_at' AND p_sort_direction = 'asc' THEN l.created_at END ASC,
    CASE WHEN p_sort_column = 'created_at' AND p_sort_direction = 'desc' THEN l.created_at END DESC,
    CASE WHEN p_sort_column = 'price_per_day' AND p_sort_direction = 'asc' THEN l.price_per_day END ASC,
    CASE WHEN p_sort_column = 'price_per_day' AND p_sort_direction = 'desc' THEN l.price_per_day END DESC,
    CASE WHEN p_sort_column = 'average_rating' AND p_sort_direction = 'asc' THEN COALESCE(rev.average_rating, 0) END ASC,
    CASE WHEN p_sort_column = 'average_rating' AND p_sort_direction = 'desc' THEN COALESCE(rev.average_rating, 0) END DESC,
    CASE WHEN p_sort_column = 'view_count' AND p_sort_direction = 'desc' THEN l.view_count END DESC NULLS LAST
LIMIT p_limit
OFFSET p_offset;
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION public.get_listings_with_ratings(text, text, numeric, numeric, numeric, double precision, double precision, integer, integer, integer, text, text, uuid, uuid) TO authenticated, service_role;


-- Function to get conversation details for the inbox
DROP FUNCTION IF EXISTS public.get_user_conversations_with_details();
CREATE OR REPLACE FUNCTION public.get_user_conversations_with_details()
RETURNS TABLE(
    conversation_id uuid,
    last_message_content text,
    last_message_time timestamptz,
    listing_id uuid,
    listing_title text,
    renter_id uuid,
    owner_id uuid,
    renter_details jsonb,
    owner_details jsonb
)
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    WITH last_messages AS (
        SELECT DISTINCT ON (m.conversation_id)
            m.conversation_id,
            m.content,
            m.created_at
        FROM public.messages m
        ORDER BY m.conversation_id, m.created_at DESC
    )
    SELECT
        c.id as conversation_id,
        lm.content as last_message_content,
        lm.created_at as last_message_time,
        c.listing_id,
        l.title as listing_title,
        c.renter_id,
        c.owner_id,
        jsonb_build_object('id', r.id, 'full_name', r.full_name, 'avatar_url', r.avatar_url) as renter_details,
        jsonb_build_object('id', o.id, 'full_name', o.full_name, 'avatar_url', o.avatar_url) as owner_details
    FROM
        public.conversations c
    LEFT JOIN
        last_messages lm ON c.id = lm.conversation_id
    JOIN
        public.listings l ON c.listing_id = l.id
    JOIN
        public.profiles r ON c.renter_id = r.id
    JOIN
        public.profiles o ON c.owner_id = o.id
    WHERE
        (c.owner_id = auth.uid() OR c.renter_id = auth.uid())
    ORDER BY
        lm.created_at DESC NULLS LAST;
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION public.get_user_conversations_with_details() TO authenticated, service_role;


-- Function to get booking requests for an owner
DROP FUNCTION IF EXISTS public.get_owner_booking_requests();
CREATE OR REPLACE FUNCTION public.get_owner_booking_requests()
RETURNS TABLE(
    id bigint,
    listing_id uuid,
    listing_title text,
    listing_image text,
    start_date date,
    end_date date,
    total_price numeric,
    status text,
    renter_id uuid,
    renter_name text,
    renter_avatar text,
    conversation_id uuid
)
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT
        b.id,
        b.listing_id,
        l.title as listing_title,
        l.images_urls[1] as listing_image,
        b.start_date,
        b.end_date,
        b.total_price,
        b.status,
        b.renter_id,
        p.full_name as renter_name,
        p.avatar_url as renter_avatar,
        c.id as conversation_id
    FROM
        public.bookings b
    JOIN
        public.listings l ON b.listing_id = l.id
    JOIN
        public.profiles p ON b.renter_id = p.id
    LEFT JOIN
        public.conversations c ON b.listing_id = c.listing_id AND b.renter_id = c.renter_id
    WHERE
        l.owner_id = auth.uid()
    ORDER BY
        b.created_at DESC;
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION public.get_owner_booking_requests() TO authenticated, service_role;


-- Function to get conversation details for a specific conversation
DROP FUNCTION IF EXISTS public.get_conversation_details(p_conversation_id uuid);
CREATE OR REPLACE FUNCTION public.get_conversation_details(p_conversation_id uuid)
RETURNS TABLE(
    id uuid,
    listing_id uuid,
    listing_title text,
    renter_id uuid,
    owner_id uuid,
    renter_details jsonb,
    owner_details jsonb,
    messages jsonb
)
SECURITY DEFINER
AS $$
BEGIN
    -- Check if user is part of the conversation
    IF NOT EXISTS (
        SELECT 1 FROM public.conversations c
        WHERE c.id = p_conversation_id AND (c.renter_id = auth.uid() OR c.owner_id = auth.uid())
    ) THEN
        RAISE EXCEPTION 'User is not a participant of conversation %', p_conversation_id;
    END IF;

    RETURN QUERY
    SELECT
        c.id,
        c.listing_id,
        l.title as listing_title,
        c.renter_id,
        c.owner_id,
        jsonb_build_object('id', r.id, 'full_name', r.full_name, 'avatar_url', r.avatar_url) as renter_details,
        jsonb_build_object('id', o.id, 'full_name', o.full_name, 'avatar_url', o.avatar_url) as owner_details,
        (
            SELECT jsonb_agg(
                jsonb_build_object(
                    'id', m.id,
                    'content', m.content,
                    'created_at', m.created_at,
                    'sender_id', m.sender_id
                ) ORDER BY m.created_at ASC
            )
            FROM public.messages m
            WHERE m.conversation_id = p_conversation_id
        ) as messages
    FROM
        public.conversations c
    JOIN
        public.listings l ON c.listing_id = l.id
    JOIN
        public.profiles r ON c.renter_id = r.id
    JOIN
        public.profiles o ON c.owner_id = o.id
    WHERE
        c.id = p_conversation_id;
END;
$$ LANGUAGE plpgsql;
GRANT EXECUTE ON FUNCTION public.get_conversation_details(p_conversation_id uuid) TO authenticated, service_role;


-- 4. Admin-specific functions
-- Helper function to check if the current user is an admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin'
  );
$$;

-- Function for admins to set a user's role
CREATE OR REPLACE FUNCTION public.set_user_role(p_user_id uuid, p_role text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can change user roles.';
  END IF;

  UPDATE public.profiles SET role = p_role WHERE id = p_user_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.set_user_role(p_user_id uuid, p_role text) TO authenticated;

-- Function for admins to ban or unban a user
CREATE OR REPLACE FUNCTION public.set_user_ban_status(p_user_id uuid, p_is_banned boolean, p_reason text DEFAULT NULL, p_duration_days integer DEFAULT NULL)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_ban_expires_at timestamptz;
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can change ban status.';
  END IF;

  IF p_is_banned AND p_duration_days IS NOT NULL THEN
    v_ban_expires_at := now() + (p_duration_days * interval '1 day');
  ELSE
    v_ban_expires_at := null;
  END IF;

  UPDATE public.profiles 
  SET 
    is_banned = p_is_banned,
    ban_reason = CASE WHEN p_is_banned THEN p_reason ELSE null END,
    ban_expires_at = v_ban_expires_at
  WHERE id = p_user_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.set_user_ban_status(uuid, boolean, text, integer) TO authenticated;

-- Function for admins to set a listing's status
CREATE OR REPLACE FUNCTION public.set_listing_status(p_listing_id uuid, p_status text, p_reason text DEFAULT NULL)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can change listing status.';
  END IF;

  UPDATE public.listings 
  SET 
    status = p_status,
    rejection_reason = CASE WHEN p_status = 'rejected' THEN p_reason ELSE null END
  WHERE id = p_listing_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.set_listing_status(uuid, text, text) TO authenticated;

-- Function for admins to verify a listing
CREATE OR REPLACE FUNCTION public.set_listing_verification(p_listing_id uuid, p_is_verified boolean)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can change verification status.';
  END IF;

  UPDATE public.listings SET is_verified = p_is_verified WHERE id = p_listing_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.set_listing_verification(p_listing_id uuid, p_is_verified boolean) TO authenticated;

-- Function for admins to search all users
CREATE OR REPLACE FUNCTION public.search_users(p_search_term text)
RETURNS TABLE (
    id uuid,
    full_name text,
    email text,
    avatar_url text,
    role text,
    is_banned boolean,
    ban_reason text,
    ban_expires_at timestamptz,
    created_at timestamptz
)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can search users.';
  END IF;

  RETURN QUERY
  SELECT
    p.id,
    p.full_name,
    u.email,
    p.avatar_url,
    p.role,
    p.is_banned,
    p.ban_reason,
    p.ban_expires_at,
    p.created_at
  FROM public.profiles p
  JOIN auth.users u ON p.id = u.id
  WHERE
    p_search_term IS NULL OR
    p.full_name ILIKE '%' || p_search_term || '%' OR
    u.email ILIKE '%' || p_search_term || '%' OR
    p.id::text ILIKE '%' || p_search_term || '%';
END;
$$;
GRANT EXECUTE ON FUNCTION public.search_users(text) TO authenticated;


-- 5. Set up storage policies
-- Note: These policies assume a 'listings' bucket exists.
-- You must create this bucket manually in your Supabase dashboard if it doesn't exist.

DROP POLICY IF EXISTS "Listing images are publicly viewable" ON storage.objects;
CREATE POLICY "Listing images are publicly viewable"
ON storage.objects FOR SELECT
TO public
USING ( bucket_id = 'listings' );

DROP POLICY IF EXISTS "Users can upload images for their own listings" ON storage.objects;
CREATE POLICY "Users can upload images for their own listings"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'listings' AND (storage.foldername(name))[1] = auth.uid()::text );

DROP POLICY IF EXISTS "Users can update their own listing images" ON storage.objects;
CREATE POLICY "Users can update their own listing images"
ON storage.objects FOR UPDATE
TO authenticated
USING ( bucket_id = 'listings' AND (storage.foldername(name))[1] = auth.uid()::text );

DROP POLICY IF EXISTS "Users can delete their own listing images" ON storage.objects;
CREATE POLICY "Users can delete their own listing images"
ON storage.objects FOR DELETE
TO authenticated
USING ( bucket_id = 'listings' AND (storage.foldername(name))[1] = auth.uid()::text );

-- Note: These policies assume an 'avatars' bucket exists.
DROP POLICY IF EXISTS "Avatar images are publicly viewable" ON storage.objects;
CREATE POLICY "Avatar images are publicly viewable"
ON storage.objects FOR SELECT
TO public
USING ( bucket_id = 'avatars' );

DROP POLICY IF EXISTS "Users can upload their own avatar" ON storage.objects;
CREATE POLICY "Users can upload their own avatar"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text );

DROP POLICY IF EXISTS "Users can update their own avatar" ON storage.objects;
CREATE POLICY "Users can update their own avatar"
ON storage.objects FOR UPDATE
TO authenticated
USING ( bucket_id = 'avatars' AND (storage.foldername(name))[1] = auth.uid()::text );

-- 5. Create a trigger to automatically create a profile for new users
-- This is crucial for ensuring data consistency between auth and public schemas.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  RETURN new;
END;
$$;

-- Trigger to run the function after a new user is created.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to create a profile for a user if one doesn't exist.
-- This can be called from the frontend to self-heal missing profiles.
CREATE OR REPLACE FUNCTION public.create_profile_if_not_exists()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  user_id uuid := auth.uid();
  user_email text;
  user_full_name text;
BEGIN
  -- Check if profile already exists
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = user_id) THEN
    -- Get user metadata from auth.users
    SELECT raw_user_meta_data->>'full_name', email INTO user_full_name, user_email
    FROM auth.users WHERE id = user_id;

    INSERT INTO public.profiles (id, full_name, avatar_url)
    VALUES (user_id, COALESCE(user_full_name, user_email), null);
  END IF;
END;
$$;
GRANT EXECUTE ON FUNCTION public.create_profile_if_not_exists() TO authenticated;

-- Function to check if a user is an admin
CREATE OR REPLACE FUNCTION public.is_admin(user_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM profiles
    WHERE id = user_id and role = 'admin'
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid) TO authenticated;


-- Function to get all listings for the admin dashboard
DROP FUNCTION IF EXISTS public.get_all_listings_admin();
CREATE OR REPLACE FUNCTION public.get_all_listings_admin()
RETURNS TABLE (
    id uuid,
    created_at timestamptz,
    title text,
    description text,
    price_per_day numeric,
    location_text text,
    owner_id uuid,
    images_urls text[],
    view_count integer,
    status text,
    is_verified boolean,
    rejection_reason text,
    owner_full_name text,
    owner_avatar_url text
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT public.is_admin(auth.uid()) THEN
    RAISE EXCEPTION 'Only admins can access all listings';
  END IF;

  RETURN QUERY
  SELECT
    l.id,
    l.created_at,
    l.title,
    l.description,
    l.price_per_day,
    l.location_text,
    l.owner_id,
    l.images_urls,
    l.view_count,
    l.status,
    l.is_verified,
    l.rejection_reason,
    p.full_name as owner_full_name,
    p.avatar_url as owner_avatar_url
  FROM public.listings l
  JOIN public.profiles p on l.owner_id = p.id
  ORDER BY l.created_at desc;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_all_listings_admin() TO authenticated;

-- Admin activity log table
CREATE TABLE IF NOT EXISTS public.admin_activity_log (
    id bigserial PRIMARY KEY,
    admin_id uuid REFERENCES public.profiles(id),
    action text NOT NULL,
    target_id uuid,
    target_type text,
    details jsonb,
    created_at timestamptz DEFAULT now()
);

-- Function to log admin actions
CREATE OR REPLACE FUNCTION public.log_admin_action(p_action text, p_target_id uuid, p_target_type text, p_details jsonb DEFAULT NULL)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.admin_activity_log (admin_id, action, target_id, target_type, details)
  VALUES (auth.uid(), p_action, p_target_id, p_target_type, p_details);
END;
$$;
GRANT EXECUTE ON FUNCTION public.log_admin_action(text, uuid, text, jsonb) TO authenticated;

-- Function to get all bookings for the admin dashboard
DROP FUNCTION IF EXISTS public.get_all_bookings_admin();
CREATE OR REPLACE FUNCTION public.get_all_bookings_admin()
RETURNS TABLE (
    id bigint,
    created_at timestamptz,
    listing_id uuid,
    listing_title text,
    renter_id uuid,
    renter_full_name text,
    owner_id uuid,
    owner_full_name text,
    start_date date,
    end_date date,
    total_price numeric,
    status text
)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can access all bookings.';
  END IF;

  RETURN QUERY
  SELECT
    b.id,
    b.created_at,
    b.listing_id,
    l.title as listing_title,
    b.renter_id,
    renter.full_name as renter_full_name,
    l.owner_id,
    owner.full_name as owner_full_name,
    b.start_date,
    b.end_date,
    b.total_price,
    b.status
  FROM public.bookings b
  JOIN public.listings l ON b.listing_id = l.id
  JOIN public.profiles renter ON b.renter_id = renter.id
  JOIN public.profiles owner ON l.owner_id = owner.id
  ORDER BY b.created_at DESC;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_all_bookings_admin() TO authenticated;

-- Function to get all reviews for the admin dashboard
DROP FUNCTION IF EXISTS public.get_all_reviews_admin();
CREATE OR REPLACE FUNCTION public.get_all_reviews_admin()
RETURNS TABLE (
    id uuid,
    created_at timestamptz,
    rating int,
    review_text text,
    listing_id uuid,
    listing_title text,
    reviewer_id uuid,
    reviewer_full_name text,
    reviewee_id uuid,
    reviewee_full_name text
)
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can access all reviews.';
  END IF;

  RETURN QUERY
  SELECT
    r.id,
    r.created_at,
    r.rating,
    r.review_text,
    r.listing_id,
    l.title as listing_title,
    r.reviewer_id,
    reviewer.full_name as reviewer_full_name,
    r.reviewee_id,
    reviewee.full_name as reviewee_full_name
  FROM public.user_reviews r
  LEFT JOIN public.listings l ON r.listing_id = l.id
  JOIN public.profiles reviewer ON r.reviewer_id = reviewer.id
  JOIN public.profiles reviewee ON r.reviewee_id = reviewee.id
  ORDER BY r.created_at DESC;
END;
$$;
GRANT EXECUTE ON FUNCTION public.get_all_reviews_admin() TO authenticated;

-- Function for admins to delete a review
DROP FUNCTION IF EXISTS public.delete_review_admin(p_review_id uuid);
CREATE OR REPLACE FUNCTION public.delete_review_admin(p_review_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Only admins can delete reviews.';
  END IF;

  DELETE FROM public.user_reviews WHERE id = p_review_id;
END;
$$;
GRANT EXECUTE ON FUNCTION public.delete_review_admin(p_review_id uuid) TO authenticated;

-- End of script 